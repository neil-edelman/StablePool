<!doctype html public "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html>

<head>
<!-- steal these colour values from JavaDocs; meh -->
<style type = "text/css">
	a:link,  a:visited { color: #4a6782; }
	a:hover, a:focus   { color: #bb7a2a; }
	a:active           { color: #4A6782; }
	tr:nth-child(even) { background: #dee3e9; }
	div {
		margin:  4px 0;
		padding: 0 4px 4px 4px;
	}
	table      { width: 100%; }
	td         { padding: 4px; }
	h3, h1 {
		color: #2c4557;
		background-color: #dee3e9;
		padding:          4px;
	}
	h3 {
		margin:           0 -4px;
		padding:          4px;
	}
</style>
<title>Pool.h</title>
</head>


<body>

<h1>Pool.h</h1>

<ul>
	<li><a href = "#_declarations">Declarations</a></li>
	<li><a href = "#_summary">Function Summary</a></li>
	<li><a href = "#_detail">Function Detail</a></li>
</ul>

<p>
2016 Neil Edelman, distributed under the terms of the MIT License;
see readme.txt, or <a href = "https://opensource.org/licenses/MIT">https://opensource.org/licenses/MIT</a>.
</p>
<p>
<em>&lt;T&gt;Pool</em> stores unordered <em>&lt;T&gt;</em> in a memory pool, which must be set using
<em>POOL_TYPE</em>. Pointers to the items in the pool remain valid as long as
the item is not removed and the pool is not deleted, (it is stable.) As such,
contiguity is not guaranteed; data is pre-allocated in geometrically
increasing blocks. However, when the data reaches a steady-state size, it will
eventually become contiguous when removal is uniformly sampled. That is, new
data replaces old data, which is all eventually freed. <em>Pool</em> is not designed
for iteration, reordering, or even counting, but instead to provide a fairly
contiguous space for items that may have references.
</p>
<p>
A zeroed <em>&lt;T&gt;Pool</em> is when all the members are zero, such as static data; it
has no extra memory associated with it. One can go from uninitialised to zero
with <a href = "#&lt;T&gt;Pool">&lt;T&gt;Pool</a>, sort of the constructor, and initialised to zero with
<a href = "#&lt;T&gt;Pool_">&lt;T&gt;Pool_</a>, sort of the destructor. From zeroed, when you start using
<em>&lt;T&gt;Pool</em>, it goes into an active state and has memory associated it; one must
call <a href = "#&lt;T&gt;Pool_">&lt;T&gt;Pool_</a> to free. A pool could have zero elements and still be
active, for example, when <a href = "#&lt;T&gt;PoolClear">&lt;T&gt;PoolClear</a> is called on an active pool.
</p>
<p>
<em>&lt;T&gt;Pool</em> is not synchronised. There is no way to shrink the active block in
memory, just expand it. Errors are returned with <em>errno</em>. The parameters are
preprocessor macros, and are all undefined at the end of the file for
convenience.
</p>
<dl>
	<dt>parameter: POOL_NAME, POOL_TYPE</dt>
	<dd>The name that literally becomes <em>&lt;T&gt;</em>, and a valid type associated therewith,
 accessible to the compiler at the time of inclusion; should be conformant to
 naming and to the maximum available length of identifiers. Must each be
 present before including.</dd>
	<dt>parameter: POOL_TO_STRING</dt>
	<dd>Optional print function implementing <em>&lt;T&gt;ToString</em>; makes available
 <a href = "#&lt;T&gt;PoolToString">&lt;T&gt;PoolToString</a>. Usually this is only used for debugging.</dd>
	<dt>parameter: POOL_TEST</dt>
	<dd>Unit testing framework using <em>&lt;T&gt;PoolTest</em>, included in a separate header,
 <em>../test/PoolTest.h</em>. Must be defined equal to a (random) filler function,
 satisfying <em>&lt;T&gt;Action</em>. If <em>NDEBUG</em> is not defined, turns on <em>assert</em> private
 function integrity testing. Requires <em>POOL_TO_STRING</em>.</dd>
	<dt>minimum standard</dt>
	<dd>C89</dd>
	<dt>author</dt>
	<dd>Neil</dd>
	<dt>version</dt>
	<dd>2019-03 Split <em>Pool</em> from <em>Array</em>; now stable.</dd>
	<dt>since</dt>
	<dd>2018-04 Merged <em>Stack</em> into <em>Pool</em> again.
			2018-03 Why have an extra level of indirection?
			2018-02 Errno instead of custom errors.
			2017-12 Introduced <em>POOL_PARENT</em> for type-safety.
			2017-11 Forked <em>Stack</em> from <em>Pool</em>.
			2017-10 Replaced <em>PoolIsEmpty</em> by <em>PoolElement</em>, much more useful.
			2017-10 Renamed Pool; made migrate automatic.
			2017-07 Made migrate simpler.
			2017-05 Split <em>List</em> from <em>Pool</em>; much simpler.
			2017-01 Almost-redundant functions simplified.
			2016-11 Multi-index.
			2016-08 Permute.</dd>
</dl>


<a name = "_declarations"><!-- --></a><h2>Declarations</h2>

<div><a name = "typedef void (*&lt;PT&gt;ToString)(const T *, char (*const)[12])"><!-- --></a>
<h3>typedef void (*&lt;PT&gt;ToString)(const T *, char (*const)[12])</h3>
<pre><b>typedef void (*&lt;PT&gt;ToString)(const T *, char (*const)[12])</b></pre>
<p>
Responsible for turning <em>&lt;T&gt;</em> (the first argument) into a 12 <em>char</em>
null-terminated output string (the second.) Used for <em>POOL_TO_STRING</em>.
</p>
<dl>
</dl>
</div>

<div><a name = "struct &lt;T&gt;Pool"><!-- --></a>
<h3>struct &lt;T&gt;Pool</h3>
<pre><b>struct &lt;T&gt;Pool</b></pre>
<p>
The pool. To instantiate, see <a href = "#&lt;T&gt;Pool">&lt;T&gt;Pool</a>.
</p>
<dl>
</dl>
</div>


<a name = "_summary"><!-- --></a><h2>Function Summary</h2>

<table>
<tr><th>Return Type</th><th>Function Name</th><th>Argument List</th></tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;Pool_">&lt;T&gt;Pool_</a></td>
	<td>struct &lt;T&gt;Pool *const pool</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;Pool">&lt;T&gt;Pool</a></td>
	<td>struct &lt;T&gt;Pool *const pool</td>
</tr>
<tr>
	<td>static int</td>
	<td><a href = "#&lt;T&gt;PoolRemove">&lt;T&gt;PoolRemove</a></td>
	<td>struct &lt;T&gt;Pool *const pool, T *const data</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;PoolClear">&lt;T&gt;PoolClear</a></td>
	<td>struct &lt;T&gt;Pool *const pool</td>
</tr>
<tr>
	<td>static int</td>
	<td><a href = "#&lt;T&gt;PoolReserve">&lt;T&gt;PoolReserve</a></td>
	<td>struct &lt;T&gt;Pool *const pool, const size_t min</td>
</tr>
<tr>
	<td>static T *</td>
	<td><a href = "#&lt;T&gt;PoolNew">&lt;T&gt;PoolNew</a></td>
	<td>struct &lt;T&gt;Pool *const pool</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;PoolForEach">&lt;T&gt;PoolForEach</a></td>
	<td>struct &lt;T&gt;Pool *const pool,
	const &lt;PT&gt;Action action</td>
</tr>
<tr>
	<td>static const char *</td>
	<td><a href = "#&lt;T&gt;PoolToString">&lt;T&gt;PoolToString</a></td>
	<td>const struct &lt;T&gt;Pool *const pool</td>
</tr>
</table>


<a name = "_detail"><!-- --></a><h2>Function Detail</h2>

<div><a name = "&lt;T&gt;Pool_"><!-- --></a>
<h3>&lt;T&gt;Pool_</h3>
<pre>static void <b>&lt;T&gt;Pool_</b> (struct &lt;T&gt;Pool *const pool)</pre>
<p>
Destructor for <em>pool</em>. All the <em>pool</em> contents are erased and should not be
accessed anymore; after, the <em>pool</em> takes no memory.
</p>
<dl>
	<dt>parameter: pool</dt>
	<dd>If null, does nothing.</dd>
	<dt>order</dt>
	<dd>&Theta;(blocks)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;Pool"><!-- --></a>
<h3>&lt;T&gt;Pool</h3>
<pre>static void <b>&lt;T&gt;Pool</b> (struct &lt;T&gt;Pool *const pool)</pre>
<p>
Initialises <em>pool</em> to be empty and zero. If it is <em>static</em> data then it
is initialised by default and one doesn't have to call this.
</p>
<dl>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;PoolRemove"><!-- --></a>
<h3>&lt;T&gt;PoolRemove</h3>
<pre>static int <b>&lt;T&gt;PoolRemove</b> (struct &lt;T&gt;Pool *const pool, T *const data)</pre>
<p>
Removes <em>data</em> from <em>pool</em>.
</p>
<dl>
	<dt>parameter: pool, data</dt>
	<dd>If null, returns false.</dd>
	<dt>return</dt>
	<dd>Success, otherwise <em>errno</em> will be set for valid input.</dd>
	<dt>throws: EDOM</dt>
	<dd><em>data</em> is corrupted or not part of <em>pool</em>.</dd>
	<dt>order</dt>
	<dd>Amortised <em>O(1)</em>, if the pool is in steady-state, but <em>O(log items)</em>
 for a small number of deleted items.</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;PoolClear"><!-- --></a>
<h3>&lt;T&gt;PoolClear</h3>
<pre>static void <b>&lt;T&gt;PoolClear</b> (struct &lt;T&gt;Pool *const pool)</pre>
<p>
Removes all from <em>pool</em>, but leaves the active memory alone; if one wants
to remove memory, see <a href = "#&lt;T&gt;Pool_">&lt;T&gt;Pool_</a>.
</p>
<dl>
	<dt>parameter: pool</dt>
	<dd>If null, does nothing.</dd>
	<dt>order</dt>
	<dd>O(blocks)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;PoolReserve"><!-- --></a>
<h3>&lt;T&gt;PoolReserve</h3>
<pre>static int <b>&lt;T&gt;PoolReserve</b> (struct &lt;T&gt;Pool *const pool, const size_t min)</pre>
<p>
Pre-sizes a zeroed pool to ensure that it can hold at least <em>min</em> elements.
</p>
<dl>
	<dt>return</dt>
	<dd>Success; the pool becomes active with at least <em>min</em> elements, even if
 <em>min</em> is zero.</dd>
	<dt>throws: EDOM</dt>
	<dd>The pool is active.</dd>
	<dt>throws: ERANGE</dt>
	<dd>Tried allocating more then can fit in <em>size_t</em>.</dd>
	<dt>throws: <em>malloc</em> errors</dt>
	<dd><em>IEEE Std 1003.1-2001</em>.</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;PoolNew"><!-- --></a>
<h3>&lt;T&gt;PoolNew</h3>
<pre>static T * <b>&lt;T&gt;PoolNew</b> (struct &lt;T&gt;Pool *const pool)</pre>
<p>
Gets an uninitialised new element.
</p>
<dl>
	<dt>parameter: pool</dt>
	<dd>If is null, returns null.</dd>
	<dt>return</dt>
	<dd>A new, un-initialised, element, or null and <em>errno</em> may be set.</dd>
	<dt>throws: ERANGE</dt>
	<dd>Tried allocating more then can fit in <em>size_t</em> objects.</dd>
	<dt>throws: <em>malloc</em> errors</dt>
	<dd><em>IEEE Std 1003.1-2001</em>.</dd>
	<dt>order</dt>
	<dd>amortised O(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;PoolForEach"><!-- --></a>
<h3>&lt;T&gt;PoolForEach</h3>
<pre>static void <b>&lt;T&gt;PoolForEach</b> (struct &lt;T&gt;Pool *const pool,
	const &lt;PT&gt;Action action)</pre>
<p>
Iterates though <em>pool</em> and calls <em>action</em> on all the elements. There is no
way to change the iteration order.
</p>
<dl>
	<dt>parameter: stack, action</dt>
	<dd>If null, does nothing.</dd>
	<dt>order</dt>
	<dd>O(<em>capacity</em> &times; <em>action</em>)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;PoolToString"><!-- --></a>
<h3>&lt;T&gt;PoolToString</h3>
<pre>static const char * <b>&lt;T&gt;PoolToString</b> (const struct &lt;T&gt;Pool *const pool)</pre>
<p>
Can print 4 things at once before it overwrites. One must pool
<em>POOL_TO_STRING</em> to a function implementing <em>&lt;T&gt;ToString</em> to get this
functionality.
</p>
<dl>
	<dt>return</dt>
	<dd>Prints <em>pool</em> in a static buffer.</dd>
	<dt>order</dt>
	<dd>&Theta;(1); it has a 255 character limit; every element takes some of it.</dd>
</dl>
</div>


</body>
</html>
